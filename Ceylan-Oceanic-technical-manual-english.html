<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Welcome to the Ceylan-Oceanic documentation</title>
<meta content="Oceanic, Enocean, home automation, Erlang" name="keywords" />
<link rel="stylesheet" href="pygments-default.css" type="text/css" />
<link rel="stylesheet" href="oceanic.css" type="text/css" />
<link href="oceanic-icon.png" rel="icon">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="document" id="ceylan-oceanic-enocean-facilities-in-erlang">
<h1 class="title">Ceylan-Oceanic: Enocean facilities in Erlang</h1>

<span class="target" id="top"></span><p><span class="raw-html"><a name="oceanic_top"></a></span></p>
<p><span class="raw-html"><div class="banner"><p><em>Oceanic documentation</em> <a href="http://oceanic.esperide.org">browse latest</a> <a href="https://olivier-boudeville.github.io/Ceylan-Oceanic/index.html">browse mirror</a> <a href="Ceylan-Oceanic-technical-manual-english.pdf">get PDF</a> <a href="#oceanic_top">go to top</a> <a href="#oceanic_toc">go to toc</a> <a href="#oceanic_bottom">go to bottom</a> <a href="api-doc/index.html">browse API</a> <a href="https://github.com/Olivier-Boudeville/Ceylan-Oceanic">go to project</a> <a href="mailto:about(dash)oceanic(at)esperide(dot)com?subject=[Ceylan-Oceanic]%20Remark">email us</a></p></div></span></p>
<p><span class="raw-html"><center><img src="oceanic-title.png" id="responsive-image-small"></img></span>
</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Organisation:</th><td class="field-body">Copyright (C) 2022-2023 Olivier Boudeville</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body">about (dash) oceanic (at) esperide (dot) com</td>
</tr>
<tr class="field"><th class="field-name">Creation date:</th><td class="field-body">Wednesday, September 7, 2022</td>
</tr>
<tr class="field"><th class="field-name">Lastly updated:</th><td class="field-body">Sunday, January 1, 2023</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">0.0.2</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">In development</td>
</tr>
<tr class="field"><th class="field-name">Dedication:</th><td class="field-body">Users and maintainers of the <tt class="docutils literal"><span class="pre">Ceylan-Oceanic</span></tt> library.</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body">The role of the <tt class="docutils literal"><span class="pre">Ceylan-Oceanic</span></tt> library is to provide Erlang-based facilities for the support of the Enocean building automation system.</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p>The latest version of this documentation is to be found at the <a class="reference external" href="http://oceanic.esperide.org">official Ceylan-Oceanic website</a> (<tt class="docutils literal"><span class="pre">http://oceanic.esperide.org</span></tt>).</p>
<p><span class="raw-html">This Ceylan-Oceanic documentation is also available in the PDF format (see <a href="Ceylan-Oceanic-technical-manual-english.pdf">Ceylan-Oceanic-technical-manual-english.pdf</a>), and mirrored <a href="http://olivier-boudeville.github.io/Ceylan-Oceanic/">here</a>.</span></p>
<p></p>
<p></p>
<p><span class="raw-html"><a name="oceanic_toc"></a></span></p>
<div class="contents topic" id="topic-1">
<span id="table-of-contents"></span><p class="topic-title"><strong>Table of Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="toc-entry-1">Overview</a></li>
<li><a class="reference internal" href="#a-word-about-other-standards-and-confidentiality" id="toc-entry-2">A Word About Other Standards and Confidentiality</a></li>
<li><a class="reference internal" href="#purpose" id="toc-entry-3">Purpose</a></li>
<li><a class="reference internal" href="#progress-enocean-coverage" id="toc-entry-4">Progress &amp; Enocean Coverage</a></li>
<li><a class="reference internal" href="#testing-ceylan-oceanic-in-two-steps" id="toc-entry-5">Testing Ceylan-Oceanic in Two Steps</a></li>
<li><a class="reference internal" href="#hardware-prerequisites" id="toc-entry-6">Hardware Prerequisites</a></li>
<li><a class="reference internal" href="#operating-system-support" id="toc-entry-7">Operating System Support</a></li>
<li><a class="reference internal" href="#software-prerequisites" id="toc-entry-8">Software Prerequisites</a><ul>
<li><a class="reference internal" href="#erlang-1" id="toc-entry-9">Erlang</a></li>
<li><a class="reference internal" href="#serial" id="toc-entry-10">Serial</a></li>
<li><a class="reference internal" href="#ceylan-myriad-2" id="toc-entry-11">Ceylan-Myriad</a></li>
<li><a class="reference internal" href="#ceylan-oceanic" id="toc-entry-12">Ceylan-Oceanic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-enocean" id="toc-entry-13">Testing Enocean</a><ul>
<li><a class="reference internal" href="#basic-direct-command-line-testing" id="toc-entry-14">Basic, Direct Command-line Testing</a></li>
<li><a class="reference internal" href="#with-a-graphical-serial-terminal" id="toc-entry-15">With a Graphical Serial Terminal</a></li>
<li><a class="reference internal" href="#oceanic-testing" id="toc-entry-16">Oceanic Testing</a><ul>
<li><a class="reference internal" href="#first-test-executing-a-few-common-commands" id="toc-entry-17">First test: executing a few Common Commands</a></li>
<li><a class="reference internal" href="#second-test-controlling-an-actual-device" id="toc-entry-18">Second test: controlling an actual device</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#enocean-documentation" id="toc-entry-19">Enocean Documentation</a></li>
<li><a class="reference internal" href="#protocol-information" id="toc-entry-20">Protocol Information</a><ul>
<li><a class="reference internal" href="#guarding-against-spoofing-lying-about-one-s-source-eurid-will-not-suffice" id="toc-entry-21">Guarding Against Spoofing: Lying about One's Source EURID will Not Suffice</a></li>
<li><a class="reference internal" href="#other-network-related-risks" id="toc-entry-22">Other Network-Related Risks</a></li>
<li><a class="reference internal" href="#studying-actual-protocols" id="toc-entry-23">Studying Actual Protocols</a></li>
<li><a class="reference internal" href="#usage-hints" id="toc-entry-24">Usage Hints</a><ul>
<li><a class="reference internal" href="#good-practices" id="toc-entry-25">Good Practices</a></li>
<li><a class="reference internal" href="#pairing" id="toc-entry-26">Pairing</a></li>
<li><a class="reference internal" href="#buttons-vs-rocker-transition-vs-state" id="toc-entry-27">Buttons vs Rocker: Transition vs State</a></li>
<li><a class="reference internal" href="#eltako-socket-switching-actuator-fssa" id="toc-entry-28">Eltako Socket switching actuator FSSA</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#support" id="toc-entry-29">Support</a></li>
<li><a class="reference internal" href="#additional-information" id="toc-entry-30">Additional Information</a></li>
<li><a class="reference internal" href="#similar-projects" id="toc-entry-31">Similar Projects</a></li>
<li><a class="reference internal" href="#please-react" id="toc-entry-32">Please React!</a></li>
<li><a class="reference internal" href="#ending-word" id="toc-entry-33">Ending Word</a></li>
</ul>
</div>
<p></p>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#toc-entry-1">Overview</a></h1>
<p>The Ceylan-Oceanic library provides <a class="reference external" href="http://erlang.org">Erlang</a>-based facilities for the support of the <a class="reference external" href="https://en.wikipedia.org/wiki/EnOcean">Enocean</a> building automation system, an open standard whose devices are generally energy-harvesting / very low-consumption, and wireless (supported frequencies around 900 MHz, depending on countries; for a range of up to 300 meters in the open, and up to 30 meters inside buildings) with very low traffic.</p>
<p>So Enocean, whose slogan could be &quot;no wire, no battery&quot;, is rather unique. No Wifi involved (and very little radio frequency exposure: due to energy constraints, few short, terse telegrams are exchanged; no real risk of interferences), no IP connectivity either, hence no real risk in terms of health or privacy/data leak (see next section), as Oceanic just receives / decodes / encodes / emits series of well-determined bytes, and remains in full control at all times: the gateway can only communicate with its host (hence with Oceanic), moreover through a low-level USB serial interface (no third-party driver involved on that hosting computer), and the devices only send tiny telegrams that can be listened to only at short range (up to a few dozens meters).</p>
<p>Finally, at least most of the Enocean specifications are <a class="reference external" href="https://www.enocean-alliance.org/specifications/">freely available</a>.</p>
<p>Besides Erlang, Ceylan-Oceanic relies only on <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad">Ceylan-Myriad</a> and is a rather autonomous part of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan">Ceylan</a> project. Ceylan-Oceanic can be readily built and run on most Unices, including of course GNU/Linux. An example of use of Oceanic is our <a class="reference external" href="https://us-main.esperide.org/#home-automation">US-Main home automation server</a>.</p>
<p>The Ceylan-Oceanic project repository is located <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Oceanic">here</a>.</p>
<p>At least a basic knowledge of Erlang is expected in order to use Ceylan-Oceanic.</p>
</div>
<div class="section" id="a-word-about-other-standards-and-confidentiality">
<h1><a class="toc-backref" href="#toc-entry-2">A Word About Other Standards and Confidentiality</a></h1>
<p>Compared to Enocean, more recent technologies and open standards exist, including <a class="reference external" href="https://en.wikipedia.org/wiki/Matter_(standard)">Matter</a>. They are increasingly promoted by Amazon, Apple and Google, so that they integrate with their respective home assistants; they communicate over IP.</p>
<p>Such devices are certainly convenient and often cheap, yet, as for us, we prefer not having in our home &quot;Big Five&quot;-originating black boxes generally full of sensors, cameras and microphones, running closed, proprietary, transparently-upgradable software, having their own IP connectivity (they typically obtain through DHCP their own local IP address) and therefore able to communicate rather freely with any &quot;cloud&quot; on the Internet (in practice, almost nobody blocks outgoing traffic from such dynamically-allocated IPs, knowing moreover that these devices often rely on Internet services and expect to regularly update their software).</p>
<p>So we are a bit puzzled that so many people trust such home automation devices to the point of actually happily <em>purchasing</em> them, and placing them at the core of their home - whereas there are already <a class="reference external" href="https://www.eff.org/fr/deeplinks/2022/07/ring-reveals-they-give-videos-police-without-user-consent-or-warrant">examples</a> showing, if necessary, that their owner is certainly not in full control of them.</p>
<p>Many will consider that non-IP protocols like Enocean or Z-Wave are already superseded by newer technologies like the aforementioned Matter system. Another point of view is that a standard like Enocean (that is moreover interesting for its unique energy-harvesting capabilities) is probably the last (and thus the most advanced one) that <em>can be easily trusted</em>.</p>
<p>It could also be argued that all wireless protocols are flawed anyway, as they can be relatively easily snooped and/or jammed, as opposed to wired ones (like with KNX, X10 and other PLC-based ones) that are by design safer / more reliable (albeit more expensive). At least for new buildings (as opposed to partially-renovated ones), such wired systems could be considered, but, to the best of our knowledge, no such practical (open, affordable, future-proof) option exists (and this is a bit of a pity).</p>
<p>So overall we consider that sticking to Enocean makes sense, hopefully for a long time.</p>
</div>
<div class="section" id="purpose">
<h1><a class="toc-backref" href="#toc-entry-3">Purpose</a></h1>
<p>The main motivation of Oceanic is to provide some basic home automation features, especially here in terms of security, in order to be able to:</p>
<ul class="simple">
<li><strong>intercept and decode telegrams</strong> emitted by sensors - notably single-input contacts (to detect the opening/closing of doors or windows), presence or temperature / humidity sensors or to detect electricity outages or jamming attempts, typically in order to implement one's own alarm center; should a security event happen, a network camera can be switched on, e-mails and/or <a class="reference external" href="https://mobile.esperide.org">SMS</a> can be sent, etc.</li>
<li><strong>generate and emit telegrams</strong> to control any kind of electrical devices (driven by a smart plug or an in-wall module), typically to turn on an electric heater or to run one's own presence simulator (possibly with lamps and sound devices)</li>
</ul>
</div>
<div class="section" id="progress-enocean-coverage">
<h1><a class="toc-backref" href="#toc-entry-4">Progress &amp; Enocean Coverage</a></h1>
<p>The targeted basic Enocean support has been implemented, so EEP Enocean telegrams can be intercepted and, for the supported EEPs (other ones may be quite easily added), such telegrams can be properly decoded and notified as higher-level, incoming events to be managed by one's application.</p>
<p>Reciprocally, telegrams for the supported EEPs can also be encoded and sent, and they are able to trigger appropriately-configured (Enocean) devices (actuators).</p>
<p>Oceanic can also execute a few common commands directly onto the local USB gateway chip.</p>
</div>
<div class="section" id="testing-ceylan-oceanic-in-two-steps">
<h1><a class="toc-backref" href="#toc-entry-5">Testing Ceylan-Oceanic in Two Steps</a></h1>
<p>Now, let's discuss all these subjects a bit more in-depth.</p>
</div>
<div class="section" id="hardware-prerequisites">
<h1><a class="toc-backref" href="#toc-entry-6">Hardware Prerequisites</a></h1>
<p>In terms of Enocean devices, one needs typically:</p>
<ul class="simple">
<li>any kind of emitter/sensor device, for example a single-input contact/rocker button like <a class="reference external" href="https://www.enocean.com/en/product-category/kinetic-switches-finished-products/?frequency=902">these ones</a>; opening sensors are also convenient, as we can easily act on them directly</li>
<li>a general-purpose emitter/receiver, typically a USB gateway, which includes a <a class="reference external" href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a> for asynchronous serial communication with an integrated RF module</li>
</ul>
<p>For that popular USB dongles can be purchased, which often rely on the <a class="reference external" href="https://www.enocean.com/wp-content/uploads/downloads-produkte/en/products/enocean_modules/tcm-310/user-manual-pdf/TCM310_UserManual_Oct2019.pdf">TCM 310 chip</a>; this includes the <a class="reference external" href="https://www.enocean.com/en/product/usb-300-500u-400j/">USB300</a> one (around 37 Euros in France), or the USB310 one (around 50 Euros in France) that we prefer, as it features a <a class="reference external" href="https://en.wikipedia.org/wiki/SMA_connector">SMA connector</a>, which allows an external antenna to be connected in order to boost emission / reception ranges inexpensively.</p>
<p>We will rely here on such a configuration.</p>
</div>
<div class="section" id="operating-system-support">
<h1><a class="toc-backref" href="#toc-entry-7">Operating System Support</a></h1>
<p>Once the USB dongle is connected (here on an Arch Linux host), <tt class="docutils literal">lsusb</tt> tells us that it is detected as:</p>
<pre class="code literal-block">
Bus 003 Device 009: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC
</pre>
<p>(which applies both to USB300 and USB310)</p>
<p>We will interact with this USB gateway as if it was a serial port.</p>
<p>Rather than having it designated by an obscure, potentially changing name (like <tt class="docutils literal">/dev/ttyUSB0</tt>, <tt class="docutils literal">/dev/ttyUSB1</tt>, etc.), we prefer assigning it a fixed, clearer, well-chosen path, like <tt class="docutils literal">/dev/ttyUSBEnOcean</tt>.</p>
<p>For that, one may define a suitable udev rule, typically stored in <tt class="docutils literal"><span class="pre">/etc/udev/rules.d/99-enocean.rules</span></tt>, whose content can simply <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a> be:</p>
<pre class="code literal-block">
SUBSYSTEM==&quot;tty&quot;, ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6001&quot;, SYMLINK+=&quot;ttyUSBEnOcean&quot;, MODE=&quot;0666&quot;
</pre>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Note though the different roles played by <tt class="docutils literal">==</tt> (for matching) and <tt class="docutils literal">=</tt> (for assignment).</td></tr>
</tbody>
</table>
<p>Following extra option could be added to the previous line, in order to set the group of this TTY: <tt class="docutils literal"><span class="pre">GROUP=&quot;dialout&quot;</span></tt> or <tt class="docutils literal"><span class="pre">GROUP=&quot;uucp&quot;</span></tt> (depending on the system's conventions), in which case your user shall be in that group (rather than executing <tt class="docutils literal">sudo chmod 777 /dev/ttyUSB0</tt> each time the USB dongle is inserted for example).</p>
<p>So one may prefer:</p>
<pre class="code literal-block">
SUBSYSTEM==&quot;tty&quot;, ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6001&quot;, SYMLINK+=&quot;ttyUSBEnOcean&quot;, GROUP=&quot;uucp&quot;, MODE=&quot;0660&quot;
</pre>
<p>and, to ensure that the user of interest for Oceanic (let's name it <tt class="docutils literal">stallone</tt>) belongs to that group:</p>
<pre class="code bash literal-block">
$ sudo usermod -a -G uucp stallone
</pre>
<p>One may then run <tt class="docutils literal">sudo udevadm control <span class="pre">--reload-rules</span> &amp;&amp; sudo udevadm trigger</tt> to ensure that these changes are taken into account from now on.</p>
<p>Then inserting said USB dongle should generate log entries that <tt class="docutils literal">journalctl <span class="pre">-xe</span></tt> can show, like (timestamps and hostname edited):</p>
<pre class="code literal-block">
kernel: usb 3-11: new full-speed USB device number 9 using xhci_hcd
kernel: usb 3-11: New USB device found, idVendor=0403, idProduct=6001, bcdDevice= 6.00
kernel: usb 3-11: New USB device strings: Mfr=1, Product=2, SerialNumber=3
kernel: usb 3-11: Product: FT232R USB UART
kernel: usb 3-11: Manufacturer: FTDI
kernel: usb 3-11: SerialNumber: A600AVJD
mtp-probe[74533]: checking bus 3, device 9: &quot;/sys/devices/pci0000:00/0000:00:14.0/usb3/3-11&quot;
kernel: ftdi_sio 3-11:1.0: FTDI USB Serial Device converter detected
kernel: usb 3-11: Detected FT232RL
kernel: usb 3-11: FTDI USB Serial Device converter now attached to ttyUSB0
mtp-probe[74533]: bus: 3, device: 9 was not an MTP device
mtp-probe[74548]: checking bus 3, device 9: &quot;/sys/devices/pci0000:00/0000:00:14.0/usb3/3-11&quot;
mtp-probe[74548]: bus: 3, device: 9 was not an MTP device
</pre>
<p>On insertion we have then, with the former settings:</p>
<pre class="code bash literal-block">
$ ls -l /dev/ttyUSBEnOcean /dev/ttyUSB0
 crw-rw---- <span class="m">1</span> root uucp <span class="m">188</span>, <span class="m">0</span> Nov <span class="m">13</span> <span class="m">10</span>:24 /dev/ttyUSB0
 lrwxrwxrwx <span class="m">1</span> root root      <span class="m">7</span> Nov <span class="m">13</span> <span class="m">10</span>:24 /dev/ttyUSBEnOcean -&gt; ttyUSB0
</pre>
</div>
<div class="section" id="software-prerequisites">
<h1><a class="toc-backref" href="#toc-entry-8">Software Prerequisites</a></h1>
<p>Ceylan-Oceanic relies on general-purpose services offered by <a class="reference external" href="http://myriad.esperide.org">Ceylan-Myriad</a> (implying of course <a class="reference external" href="https://myriad.esperide.org/#software-prerequisites">Erlang itself</a>), and on a suitable Erlang driver for serial communication.</p>
<div class="section" id="erlang-1">
<h2><a class="toc-backref" href="#toc-entry-9">Erlang</a></h2>
<p>If needed, follow <a class="reference external" href="https://myriad.esperide.org/#software-prerequisites">these Myriad guidelines for installing Erlang</a> in order to obtain a proper, recent-enough version thereof.</p>
</div>
<div class="section" id="serial">
<h2><a class="toc-backref" href="#toc-entry-10">Serial</a></h2>
<p id="erlang-serial">We use our version <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a> of <a class="reference external" href="https://github.com/Olivier-Boudeville/erlang-serial">erlang-serial</a> for that, which we prefer installing in user space (rather than in the system tree) that way:</p>
<pre class="code bash literal-block">
$ mkdir ~/Software <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ~/Software
$ git clone https://github.com/Olivier-Boudeville/erlang-serial
$ <span class="nb">cd</span> erlang-serial
$ make <span class="o">&amp;&amp;</span> <span class="nv">DESTDIR</span><span class="o">=</span>. make install
</pre>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>This is a fork of the original <a class="reference external" href="https://github.com/tonyg/erlang-serial">erlang-serial</a>, which had to be modified notably in terms of disabled RTS/CTS flow control, in order to be able to properly send data to the Enocean gateway.</td></tr>
</tbody>
</table>
<p>Then using <tt class="docutils literal"><span class="pre">erlang-serial</span></tt> will be just a matter of adding it to one's code path <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>.</p>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>Later in the installation one may update the <tt class="docutils literal"><span class="pre">Erlang-serial</span> section</tt> in Oceanic's <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Oceanic/blob/main/GNUmakevars.inc">GNUmakevars.inc</a> in order to take into account any other path convention. One may then run, from the root of Oceanic, <tt class="docutils literal">make <span class="pre">info-serial</span></tt> to check that <tt class="docutils literal">ERLANG_SERIAL_BASE</tt> points indeed to a directory containing erlang-serial's <tt class="docutils literal">ebin</tt> directory. Otherwise runtime checks will detect and report any issue.</td></tr>
</tbody>
</table>
<p>To test this erlang-serial installation (whether or not any dongle is connected):</p>
<pre class="code bash literal-block">
$ erl -pa <span class="nv">$HOME</span>/Software/erlang-serial/erlang/lib/serial-1.1/ebin
Erlang/OTP <span class="m">25</span> <span class="o">[</span>erts-13.0<span class="o">]</span> <span class="o">[</span>source<span class="o">]</span> <span class="o">[</span><span class="m">64</span>-bit<span class="o">]</span> <span class="o">[</span>smp:8:8<span class="o">]</span> <span class="o">[</span>ds:8:8:10<span class="o">]</span> <span class="o">[</span>async-threads:1<span class="o">]</span> <span class="o">[</span>jit:ns<span class="o">]</span>

Eshell V13.0  <span class="o">(</span>abort with ^G<span class="o">)</span>
<span class="m">1</span>&gt; serial:start<span class="o">()</span>.
&lt;<span class="m">0</span>.82.0&gt;
</pre>
<p>Perfect!</p>
</div>
<div class="section" id="ceylan-myriad-2">
<h2><a class="toc-backref" href="#toc-entry-11">Ceylan-Myriad</a></h2>
<p>Oceanic expects to find a fully-built Myriad source tree as a sibling of its own tree, named <tt class="docutils literal">myriad</tt>, and possibly made available through a symbolic link.</p>
<p>As per <a class="reference external" href="https://myriad.esperide.org/#getting-myriad-s-sources">these Myriad guidelines</a>, this source tree can be obtained by changing to a directory of choice that will contain both Myriad and Oceanic, and issuing:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-Myriad.git
$ ln -s Ceylan-Myriad myriad <span class="o">&amp;&amp;</span> <span class="nb">cd</span> myriad <span class="o">&amp;&amp;</span> make all <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ..
</pre>
</div>
<div class="section" id="ceylan-oceanic">
<h2><a class="toc-backref" href="#toc-entry-12">Ceylan-Oceanic</a></h2>
<p>From the same parent directory, very similarly:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-Oceanic.git
<span class="c1"># Symlink just for consistency:
</span>$ ln -s Ceylan-Oceanic oceanic <span class="o">&amp;&amp;</span> <span class="nb">cd</span> oceanic <span class="o">&amp;&amp;</span> make all <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ..
</pre>
</div>
</div>
<div class="section" id="testing-enocean">
<h1><a class="toc-backref" href="#toc-entry-13">Testing Enocean</a></h1>
<p>Ensure first that none of the next serial tools / terminals has been left running, otherwise exclusive access may block your ability to send telegrams thanks to Oceanic.</p>
<p>To check, one may rely on:</p>
<pre class="code bash literal-block">
$ lsof /dev/ttyUSBEnOcean
COMMAND    PID      USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
serial  <span class="m">214977</span> your_user   3u   CHR  <span class="m">188</span>,0      0t0 <span class="m">1066</span> /dev/ttyUSB0
</pre>
<p>Note also that, from that point EURIDs are altered/edited (fake ones used). Minor discrepancies may happen.</p>
<div class="section" id="basic-direct-command-line-testing">
<h2><a class="toc-backref" href="#toc-entry-14">Basic, Direct Command-line Testing</a></h2>
<p>It is as simple as executing from the command-line (thus without Oceanic, Serial or Erlang being involved):</p>
<pre class="code bash literal-block">
$ od -x &lt; /dev/ttyUSBEnOcean
<span class="m">0000000</span> <span class="m">0055</span> <span class="m">0707</span> 7a01 10f6 2e00 96e1 <span class="m">0130</span> ffff
<span class="m">0000020</span> ffff <span class="m">0039</span> 554b <span class="m">0700</span> <span class="m">0107</span> f67a <span class="m">0000</span> e12e
</pre>
<p>(of course for such a binary content to be received, Enocean telegrams must be emitted; the simplest approach is to trigger any Enocean device able to send on demand such telegrams, like a button/rocker/switch)</p>
<p><tt class="docutils literal">hexdump</tt> can be also used to intercept telegrams. If needing to set the transmission speed beforehand, use <tt class="docutils literal">stty <span class="pre">-F</span> /dev/ttyUSBEnOcean 57600</tt>.</p>
<p>Incoming data can also be recorded and &quot;replayed&quot; (yet this is not expected to activate an Enocean receiver, see <a class="reference internal" href="#protocol-information">Protocol Information</a>):</p>
<pre class="code bash literal-block">
$ cat &lt; /dev/ttyUSBEnOcean &gt; my_record.bin
$ cat my_record.bin &gt; /dev/ttyUSBEnOcean
</pre>
</div>
<div class="section" id="with-a-graphical-serial-terminal">
<h2><a class="toc-backref" href="#toc-entry-15">With a Graphical Serial Terminal</a></h2>
<p>One may use <a class="reference external" href="https://cutecom.sourceforge.net/">cutecom</a> to directly test input/output telegrams.</p>
<p>A priori neither RTS nor DTR shall be enabled (yet in our tests these had no impact with cutecom; however not disabling them with Oceanic was leading to emitting telegrams not understood by their target devices).</p>
<p>We recommend using the <tt class="docutils literal">Hex</tt> input and output.</p>
</div>
<div class="section" id="oceanic-testing">
<h2><a class="toc-backref" href="#toc-entry-16">Oceanic Testing</a></h2>
<div class="section" id="first-test-executing-a-few-common-commands">
<h3><a class="toc-backref" href="#toc-entry-17">First test: executing a few Common Commands</a></h3>
<p>This consists in having Oceanic discuss with the local USB gateway dongle, regardless of any actual Enocean device.</p>
<p>From the root of the Ceylan-Oceanic clone, supposing that Myriad and erlang-serial are already available and built (whereas here debug flags have been activated, see Oceanic's <tt class="docutils literal">GNUmakevars.inc</tt>):</p>
<pre class="code literal-block">
# Ensure erlang-serial is available:
$ make info-serial
ERLANG_SERIAL_BASE = /home/stallone/Software/erlang-serial/erlang/lib/serial-1.1

# Ensure that Ceylan-Oceanic is built:
$ make all

$ cd test

# Triggering a Common Command does not need any target device:
$ make oceanic_common_command_run

       Running unitary test oceanic_common_command_run (third form) from oceanic_common_command_test

--&gt; Testing module oceanic_common_command_test.

Testing the management of Common Commands.
[debug] Using TTY '/dev/ttyUSBEnOcean' to connect to Enocean gateway, corresponding to serial server &lt;0.86.0&gt; (speed: 57600 bits per second).
[debug] Discovering our base EURID.
[debug] Sending to serial server &lt;0.86.0&gt; actual telegram &lt;&lt;85,0,1,0,5,112,8,56&gt;&gt; (hexadecimal form: '5500010005700838').
[debug] Waiting initial base request (ToSkipLen=0, AccChunk=&lt;&lt;&gt;&gt;).
[debug] Read telegram &lt;&lt;85,0,5,1,2,219,0,255,162,223,0,10,180&gt;&gt; of size 13 bytes (corresponding to hexadecimal '5500050102db00ffa3df000ab4').
[debug] Trying to decode '&lt;&lt;85,0,5,1,2,219,0,255,162,223,0,10,180&gt;&gt;' (of size 13 bytes)
[debug] Start byte found, retaining now following chunk (of size 12 bytes; after dropping 0 byte(s)):
 &lt;&lt;0,5,1,2,219,0,255,162,223,0,10,180&gt;&gt;.
[debug] Examining now following chunk of 12 bytes:&lt;&lt;0,5,1,2,219,0,255,162,223,0,10,180&gt;&gt;.
[debug] Packet type 2; expecting 5 bytes of data, then 1 of optional data; checking first header CRC.
[debug] Header CRC validated (219).
[debug] Detected packet type: response_type.
[debug] Full-data CRC validated (180).
[debug] Decoding a command response, whereas awaiting command of type co_rd_idbase, based on telegram &lt;&lt;85,0,1,0,5,112,8,56&gt;&gt; of size 8 bytes
(corresponding to hexadecimal '5500010005700838'), on behalf of requester internal.
[debug] Returning the following internal response: read gateway base ID ffa3df00, for 10 remaining write cycles.
[debug] Successfully read gateway base ID ffa3df00, for 10 remaining write cycles.
[info] No preferences file ('/home/stallone/.ceylan-settings.etf') found.
[debug] Waiting for any message including a telegram chunk, whereas having 0 bytes to skip, and having accumulated &lt;&lt;&gt;&gt;.
[debug] Requested to execute common command 'co_rd_version', on behalf of requester &lt;0.9.0&gt;.
[...]
[debug] Sending back to requester &lt;0.9.0&gt; the following response: read application
version 2.11.1.0, API version 2.6.3.0, chip ID 19d46ce, chip version 1162805507 and application description 'GATEWAYCTRL'.
[debug] Waiting for any message including a telegram chunk, whereas having 0 bytes to skip, and having accumulated &lt;&lt;&gt;&gt;.
Read version: read application version 2.11.1.0, API version 2.6.3.0, chip ID 19d46bc, chip version 1162805507 and application description 'GATEWAYCTRL'.
[debug] Requested to execute common command 'co_rd_sys_log', on behalf of requester &lt;0.9.0&gt;.
[...]
Read logs: read counters: 6 for application: [254,255,255,255,255,255], and 38 for API: [255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].
[debug] Stopping the Oceanic server &lt;0.85.0&gt;.
[debug] Stopping serial server &lt;0.86.0&gt;, while in following state: Oceanic server using serial server &lt;0.86.0&gt;, using emitter EURID ffa3df00,
not having any command pending, based on a time-out of 1 second, with no command queued whereas a total of 2 of them have been issued;
having &lt;0.9.0&gt; registered as listener of Enocean events, having sent 3 telegrams, not having discarded any telegram, and knowing no Enocean device
[debug] Oceanic server &lt;0.85.0&gt; terminated.
Stopped.

--&gt; Successful end of test.

(test finished, interpreter halted)
</pre>
</div>
<div class="section" id="second-test-controlling-an-actual-device">
<h3><a class="toc-backref" href="#toc-entry-18">Second test: controlling an actual device</a></h3>
<p>This more complete test will rely on experimental settings typically involving:</p>
<ul class="simple">
<li>a <strong>controller device</strong> (e.g. a double-rocker switch), which will be, once discovered, spoofed next by Oceanic</li>
<li>a <strong>target device</strong> (e.g. a smart plug / socket switching actuator) that already learnt - according to its own procedure (typically pressing adequately buttons thereof) - the previous controller device; for example a lamp would be plugged on that actuator so that, when pressing and releasing a given button of the rocker switch, the lamp is toggled (on/off)</li>
</ul>
<p>The objective is to control that lamp programmatically, through Oceanic (only).</p>
<p>First, the EURID of the controller device must be determined. Either it can be directly read from some actual label on the device, or it has to be obtained through passive listening.</p>
<p>In this last case, start by running the following test (still in <tt class="docutils literal">oceanic/test</tt>):</p>
<pre class="code literal-block">
$ make oceanic_integration_run

       Running unitary test oceanic_integration_run (third form) from oceanic_integration_test

--&gt; Testing module oceanic_integration_test.

(test waiting indefinitely for Enocean events; hit CTRL-C to stop)
[debug] Using TTY '/dev/ttyUSBEnOcean' to connect to Enocean gateway, corresponding to serial server &lt;0.86.0&gt; (speed: 57600 bits per second).
[debug] Discovering our base EURID.
[...]
[debug] Waiting for any message including a telegram chunk, whereas having no byte to skip, and having accumulated no chunk.
</pre>
<p>Then act on the controller so that it emits a telegram (e.g. press a button of said rocker switch; it may be correspond for example to the bottom position of the first rocker, <tt class="docutils literal">A</tt>).</p>
<p>If in range, the test should intercept it:</p>
<pre class="code literal-block">
[debug] Received a telegram chunk of 21 bytes: &lt;&lt;85,0,7,7,1,122,246,48,0,46,225,150,48,1,255,255,255,255,68,0,254&gt;&gt;, corresponding to
hexadecimal 55000707017af630002ef1963001ffffffff4400fe (whereas there are 0 bytes to skip).[...]
[debug] Decoding an ERP1 radio packet of R-ORG f6, hence rorg_rps, i.e. 'RPS (Repeated Switch Communication)'...
[info] Discovering Enocean device 002ef196 through failure.

&lt;----------------
[warning] Unable to decode a RPS (F6) packet for 002ef196: device not configured, no EEP known for it.
----------------&gt;

[debug] Waiting for any message including a telegram chunk, whereas having no byte to skip, and having accumulated no chunk.
[...]
</pre>
<p>(hit CTRL-C to stop)</p>
<p>So we determined that this rocker switch has for EURID <tt class="docutils literal">002ef196</tt>.</p>
<p>We can notice that a failure is reported, as Oceanic cannot decode yet the telegrams from that emitter, short of knowing to which EEP it complies. As this EEP information is not carried by such packets, it cannot be determined automatically and has thus to be specified, here once for all through a proper Oceanic configuration file, typically to be found as <tt class="docutils literal"><span class="pre">~/.ceylan-settings.etf</span></tt>.</p>
<p>In this <a class="reference external" href="https://myriad.esperide.org/#etf">ETF file</a>, among possibly other entries unrelated to Oceanic, we may have:</p>
<pre class="code erlang literal-block">
<span class="c">% Oceanic section:</span><span class="w">

</span><span class="c">% Information regarding the pseudo-device emitting any telegram to be sent by</span><span class="w">
</span><span class="c">% Oceanic:</span><span class="w">
</span><span class="c">%</span><span class="w">
</span><span class="c">% (if overriding the base ID of this chip, read as &quot;ffa3df00&quot;)</span><span class="w">
</span><span class="c">%</span><span class="w">
</span><span class="c">%{ oceanic_emitter, &quot;DEADBEEF&quot; }.</span><span class="w">

</span><span class="c">% To spoof my green switch:</span><span class="w">
</span><span class="c">%{ oceanic_emitter, &quot;002EF196&quot; }.</span><span class="w">


</span><span class="c">% A list of device_config() entries, clearer with user-defined names than with</span><span class="w">
</span><span class="c">% only raw EURIDs:</span><span class="w">
</span><span class="c">%</span><span class="w">
</span><span class="p">{</span><span class="w"> </span><span class="n">oceanic_devices</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w">

   </span><span class="c">% Either {UserDefinedName :: ustring(), EURID :: ustring(), EEP ::</span><span class="w">
   </span><span class="c">% ustring()} or {UserDefinedName :: ustring(), EURID :: ustring(),</span><span class="w">
   </span><span class="c">%                EEP :: ustring(), Comment :: ustring()}:</span><span class="w">

   </span><span class="c">% For the local gateway (useful to decode/check self-encoded telegrams):</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;my local USB gateway&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ffa3df00&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F6-02-01&quot;</span><span class="w"> </span><span class="p">},</span><span class="w">

   </span><span class="c">% Single-input contacts:</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;my first opening sensor&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;060533EC&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;D5-00-01&quot;</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;my second opening sensor&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;02959F62&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;D5-00-01&quot;</span><span class="w"> </span><span class="p">},</span><span class="w">

   </span><span class="c">% Temperature and humidity sensors:</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;my only temperature and humidity sensor&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;02A96926&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A5-04-01&quot;</span><span class="w"> </span><span class="p">},</span><span class="w">

   </span><span class="c">% Switches:</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;my green switch&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;002EF196&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F6-02-01&quot;</span><span class="p">,</span><span class="w">
     </span><span class="s">&quot;This is actually a single-rocker switch&quot;</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;my white switch&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;012F50D6&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F6-02-01&quot;</span><span class="w"> </span><span class="p">},</span><span class="w">

   </span><span class="c">% In-wall modules:</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;my two-channel orange module&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;06035E4A&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;D2-01-12&quot;</span><span class="w"> </span><span class="p">}</span><span class="w">

   </span><span class="c">% Socket switching actuators:</span><span class="w">
   </span><span class="c">%{ &quot;my smart plug&quot;, (unknown), (unknown) }</span><span class="w">

   </span><span class="p">]</span><span class="w"> </span><span class="p">}.</span>
</pre>
<p>These entries are pretty self-explanatory:</p>
<ul class="simple">
<li>with <tt class="docutils literal">oceanic_emitter</tt> we define the EURID that shall be used by Oceanic whenever emitting (the default being its in-chip first base ID, as automatically determined thanks to a Common Command)</li>
<li>with <tt class="docutils literal">oceanic_devices</tt> the EEP of the various devices that we want to be aware of are listed (naming them allows to have clearer Oceanic reports)</li>
</ul>
<p>Now, as the test explicitly sets the EURID of the emitter, it is just a matter of updating,  in <tt class="docutils literal">oceanic_static_sending_test.erl</tt>, the <tt class="docutils literal">SourceEurid</tt> variable in order that this test impersonates the controller of interest (here, said green switch):</p>
<pre class="code erlang literal-block">
<span class="nv">SourceEurid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">oceanic</span><span class="p">:</span><span class="nf">string_to_eurid</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;002EF196&quot;</span><span class="w"> </span><span class="p">),</span>
</pre>
<p>Running it <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a> results in:</p>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>The decoding printout corresponds to a check made by this test: prior to sending a telegram that it just generated, it ensures that it can decode it successfully.</td></tr>
</tbody>
</table>
<pre class="code literal-block">
$ make oceanic_static_sending_run
       Running unitary test oceanic_static_sending_run (third form) from oceanic_static_sending_test

--&gt; Testing module oceanic_static_sending_test.

Starting test; note that direct telegram sendings are made here, thus Oceanic will detect responses that do not match with any past request that it sent.
[debug] Using TTY '/dev/ttyUSBEnOcean' to connect to Enocean gateway, corresponding to serial server &lt;0.86.0&gt; (speed: 57600 bits per second).
[debug] Discovering our base EURID.

[debug] Successfully read gateway base ID ffa3df00, for 10 remaining write cycles.
[debug] Initial state: Oceanic server using serial server &lt;0.86.0&gt;, using emitter EURID ffa3df00, not having any command pending, based
on a time-out of 1 second, with no command queued whereas none has been issued; not having a listener of Enocean events registered,
having sent a single telegram, not having discarded any telegram, and knowing 8 Enocean devices:
+ device 'my first opening sensor' (EURID: 060533ec) applying EEP D5-00-01; it has been never seen by this server
[...]
Decoding the 'pressed' one for the 'off' button results in following event: double-rocker device 'my green switch' (whose EURID is 002ef196) has no button
pressed simultaneously at 2022/11/19 23:11:45, declared with a single subtelegram, targeted to the address for broadcast transmission; security
level: telegram not processed; its EEP is double_rocker_switch (F6-02-01)
[...]
All telegrams of interest encoded.
First we press (and then also release) the 'switch off' button, 'button_ao' (which must have already been learnt), typically in order to switch on a lamp.
Then, after a short waiting, we press (and then release) this 'switch off' button again, 'button_ai', typically to switch off the lamp.
[debug] Sending to serial server &lt;0.86.0&gt; actual telegram &lt;&lt;85,0,7,7,1,122,246,16,1,9,217,112,32,1,255,255,255,255,255,0,204&gt;&gt;
(hexadecimal form: '55000707017af6100109d9702001ffffffffff00cc').
</pre>
<p>The lamp is expected first to turn on, then, and after one second, to turn off.</p>
<p>Congratulations, your Oceanic program can control electrical appliances!</p>
<p>If this test does not work as intended:</p>
<ul class="simple">
<li>did the right position of the right button was learnt?</li>
<li>depending on the switch, apparently:<ul>
<li>either each of the individual buttons will act as a rocker by itself (e.g. to switch on then off the lamp, a learnt button - top or bottom - of a given rocker will have to be pressed and released twice <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>)</li>
<li>or the whole rocker (that is the pair made of its top and bottom buttons) will work as intended as a rocker (e.g. to switch on the lamp, the top button will have to be pressed and released, then, to switch off the lamp, the bottom button will have to be pressed and released <a class="footnote-reference" href="#footnote-6" id="footnote-reference-6">[6]</a>)</li>
</ul>
</li>
</ul>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>This is the case for my white switch, an O2 Line Comfort double-rocker; the top and bottom buttons can then be used indifferently.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-6">[6]</a></td><td>This is the case for my green switch, a VIMAR Vita (single) rocker, for which each button has a role. For example, pressing a given button more than once will have no effect (as it corresponds to a state already reached), only using the other will trigger a new transition.</td></tr>
</tbody>
</table>
<p></p>
</div>
</div>
</div>
<div class="section" id="enocean-documentation">
<h1><a class="toc-backref" href="#toc-entry-19">Enocean Documentation</a></h1>
<ul class="simple">
<li>[ETS]: <a class="reference external" href="https://www.enocean-alliance.org/specifications/">Enocean Technical Specifications</a>, notably for:<ul>
<li>[EEP-gen]: <a class="reference external" href="https://www.enocean-alliance.org/eep/">EnOcean Equipment Profiles</a> (e.g. version 3.1.4, 36 pages), a short, general view onto the structure of the various telegram types that are available (e.g. the RPS one)</li>
<li>[EEP-spec]: <a class="reference external" href="https://www.enocean-alliance.org/wp-content/uploads/2017/05/EnOcean_Equipment_Profiles_EEP_v2.6.7_public.pdf">EEP Specification</a> (e.g. version 2.6.7, 270 pages), for a detailed specification of the various equipment profiles (e.g. <tt class="docutils literal"><span class="pre">F6-01-*</span></tt> being for <em>Switch Buttons</em>)</li>
</ul>
</li>
<li>[ESP3]: <a class="reference external" href="https://www.enocean.com/esp">Enocean Serial Protocol (ESP3) - SPECIFICATION</a> (e.g. version 1.51, 116 pages), a point-to-point packet-based protocol that is lower-level in the network stack; of lesser interest here)</li>
</ul>
<p>Note also that, despite the availability of ERP2 specifications, at least most devices we are aware of rely on ERP1 ones.</p>
</div>
<div class="section" id="protocol-information">
<h1><a class="toc-backref" href="#toc-entry-20">Protocol Information</a></h1>
<div class="section" id="guarding-against-spoofing-lying-about-one-s-source-eurid-will-not-suffice">
<h2><a class="toc-backref" href="#toc-entry-21">Guarding Against Spoofing: Lying about One's Source EURID will Not Suffice</a></h2>
<p>Provided that the serial link is properly configured (in terms of speed, parity, start/stop bits, RTS/CTS flow control, etc.), apparently even with the default, usual level of security (that is: none) implemented by the devices that we tested, Enocean telegrams could <em>not</em> be replayed <a class="footnote-reference" href="#footnote-7" id="footnote-reference-7">[7]</a>: just intercepting a raw telegram and re-emitting was not acknowledged by the target device and did not trigger its intended effect on at least our <a class="reference internal" href="#main-test-actuator">main test actuator</a> (e.g. the smart plug did not switch on/off).</p>
<table class="docutils footnote" frame="void" id="footnote-7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-7">[7]</a></td><td>See the <tt class="docutils literal">replay_telegrams/1</tt> function in the <tt class="docutils literal">oceanic_just_send_to_device_test</tt> module for an example.</td></tr>
</tbody>
</table>
<p>One explanation could have been that we were re-emitting from Oceanic &quot;receive&quot; telegrams (as opposed to &quot;send&quot; ones), as we actually always receive information different from what was sent (e.g. the dbM measure, the repeating count, etc. are visibly set between the emission and the receiving; and of course the checksums are modified accordingly) - so replaying a received telegram <em>could</em> be rejected on these bases.</p>
<p>Nevertheless, forging from scratch proper &quot;send telegrams&quot; (yet carrying the same functional information) and sending them by ourselves still did not trigger the actuator (we did multiple tests on multiple devices of different manufacturers).</p>
<p>So we believe that extra information is available to actuators through the Enocean network stack, that may/will be used by them in order to discriminate between actual emitters.</p>
<p>This was further confirmed by testing the same telegram exchanges after having learnt a device, either the real one, or one impersonated by Oceanic: apparently, only the ones that have been explicitly learnt previously will be accepted afterwards.</p>
<p>By forging telegrams bearing a source EURID different from the base one, we came to the conclusion that:</p>
<ul class="simple">
<li>most if not all telegrams carry a source EURID that can be freely set (typically through Oceanic calls)</li>
<li>yet in parallel each emitter (be them an USB dongle controlled by Oceanic or a &quot;real&quot; device) has its own internal, &quot;base&quot; ID (or a base ID range, for such dongles); these IDs have the same type as EURIDs, and we suppose that they can be considered as actual EURIDs - yet they <em>could</em> be handled specifically only in low-level ESP3-like protocols (invisibly from the &quot;applicative layer&quot; seen when exchanging with the dongle); by default, unless specified (see the <tt class="docutils literal">oceanic_emitter</tt> configuration entry), the source EURID used by telegrams generated by Oceanic match the ID obtained (through a Common Command) from the USB dongle <a class="footnote-reference" href="#footnote-8" id="footnote-reference-8">[8]</a></li>
<li>learning a device relies at least on these internal IDs, sometimes also on the specified in-telegram source one</li>
<li>a telegram will be considered by an actuator iff the internal ID of the emitter carried by this telegram matches with one that has been learnt by the actuator (hence no easy spoofing with rogue, undeclared emitters)</li>
<li>the source EURID included in a telegram will designate a device but may not match the internal ID of the emitter; so for example we could forge, from Oceanic, telegrams whose source EURID matches the one of an actual device (a rocker switch) - and therefore did not match the internal ID of the dongle - while nevertheless, <em>provided that the dongle had already been learnt by the actuator, typically thanks to a previous Oceanic sending</em>, we could operate the actuator programmatically (despite these telegrams having inconsistent IDs)</li>
<li>yet, do these Oceanic telegrams have to specify the same EURID as used for their registering, or any already-registered EURID - or would any EURID would do the trick?</li>
</ul>
<ul>
<li><p class="first">for the repeating mechanisms to have an interest, their re-emitted telegrams must be taken into account by the target actuators; so accepting already-sent telegrams emanating from different emitters than the one specified in the telegrams is needed; repeating is most probably handled transparently by lower-level protocols as well</p>
<table class="docutils footnote" frame="void" id="footnote-8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-8">[8]</a></td><td><p class="first last">This is merely a convention though, as apparently any another EURID could be used instead at this level. We used to add &quot;<em>provided it is consistently used from then on</em>&quot; (that is: when learning and also when sending telegram afterwards), yet we could see that even forging a telegram with a random source EURID but sending it from a right, already learnt device (hence using another EURID then) is sufficient to have the corresponding request accepted and processed - at least by some actuators.</p>
</td></tr>
</tbody>
</table>
</li>
</ul>
<p>We can also verify that devices like rocker switches are apparently stateless, in the sense that they seem to send the same information regardless of their history when one of their buttons is pressed (they have no memory).</p>
<p>So from our experiments we believe that, in terms of identification, the devices rely on a lower-level protocol (possibly ESP3) than the one that can be handled programmatically (e.g. ERP1 and siblings); as these operations seem to be done through the firmware of the USB gateway, spoofing Enocean traffic may be out of the reach of programs relying on &quot;standard&quot; USB gateways (therefore Oceanic having to be involved also in the learn process, not only in the emitting one).</p>
<p>And forging custom source EURIDs may have an interest, yet the spoofer must have been previously learnt - otherwise this would be a bit like if one was spoofing IP addresses in forged packets, whereas the target device would first compare MAC addresses.</p>
</div>
<div class="section" id="other-network-related-risks">
<h2><a class="toc-backref" href="#toc-entry-22">Other Network-Related Risks</a></h2>
<p>The spoofing risk being mostly alleviated, the only extra risks that we could foresee are:</p>
<ul class="simple">
<li>possibly <strong>brute-force attempts</strong> to match already-learnt base identifiers, from a debug gateway allowing to act on ESP3 packets (a threat that does not seem likely for common burglaries)</li>
<li>the <strong>jamming of an actuator</strong> by saturating it with telegrams (be them well-formed and sensible, or not <a class="footnote-reference" href="#footnote-9" id="footnote-reference-9">[9]</a>), so that any actual telegram of interest (e.g. regarding a door opening) may not reach the receiver</li>
<li>sensors devices being <strong>incapacitated before they are able to raise an alarm</strong> (for example destroyed, or possibly flashed by an electromagnetic impulse)</li>
</ul>
<table class="docutils footnote" frame="void" id="footnote-9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-9">[9]</a></td><td>A battery-operated, generic-purpose jammer operating on the usual frequencies, like 868 MHz in Europe, may be able to affect most of the (now wireless) protocols for house-automation just by emitting powerfully-enough random noise on these bandwidths.</td></tr>
</tbody>
</table>
<p>Oceanic provides basic yet possibly sufficient mechanisms guarding against these three threats.</p>
<p>For the first two risks: in a wireless context, nothing can be done against emission, but a configurable threshold in terms of incoming traffic volume can be monitored (with proper back-off), so that, if the application registered as a listener, Oceanic notifies it whenever detecting such an attempt of denial of service - which can be considered by itself as a cause of alarm as serious as the other ones.</p>
<p>This threshold is expressed in bytes per second (knowing that telegrams are often fragmented), and its default value (see the <tt class="docutils literal">oceanic_jamming_threshold</tt> configuration entry) is <tt class="docutils literal">250</tt>. As the size of many Enocean legit telegrams is 21 bytes, an <tt class="docutils literal">onEnoceanJamming</tt> event will be sent to the Oceanic-using application should a dozen of them be received during the same second, or a bit more in (a bit) longer time window (e.g. 20 in two seconds).</p>
<p>For the last risk, sensors (typically opening detectors) report instantly state transitions but also send periodic state notifications (even if no change happened). So a listener can monitor the duration elapsed since such a sensor was last seen, and if it exceeds a threshold (for example 30 minutes <a class="footnote-reference" href="#footnote-10" id="footnote-reference-10">[10]</a>), this may considered as a reason to raise an alarm.</p>
<table class="docutils footnote" frame="void" id="footnote-10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-10">[10]</a></td><td>So the event will be detected, albeit with a latency that, depending on the use case, may or may not be acceptable / useful.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="studying-actual-protocols">
<h2><a class="toc-backref" href="#toc-entry-23">Studying Actual Protocols</a></h2>
<p>To experiment and troubleshoot communication issues (this may be especially of use should different devices/actuators interpret differently the Enocean specifications / develop their own behaviour), one may also use tests that perform direct listening / emitting (possibly bypassing partly the logic of the Oceanic server):</p>
<ul class="simple">
<li>use <tt class="docutils literal">make oceanic_just_record_device_run</tt> to display and record in file (<tt class="docutils literal"><span class="pre">enocean-test-recording.etf</span></tt>) all raw, timestamped telegrams that can be intercepted</li>
<li>use <tt class="docutils literal">make oceanic_just_send_to_device_run</tt> to emit raw telegrams, typically recorded as explained above or forged (encoded) by Oceanic</li>
</ul>
<p>Corresponding very handy scripts are available as well, <tt class="docutils literal"><span class="pre">decode-telegram.sh</span></tt> and <tt class="docutils literal"><span class="pre">send-telegram.sh</span></tt>, to which a raw telegram can be given (as an hexadecimal string).</p>
</div>
<div class="section" id="usage-hints">
<h2><a class="toc-backref" href="#toc-entry-24">Usage Hints</a></h2>
<div class="section" id="good-practices">
<h3><a class="toc-backref" href="#toc-entry-25">Good Practices</a></h3>
<p>Before any new test, one should properly fully reset one's actuator, otherwise weird / wild / overly complex interpretations may happen.</p>
</div>
<div class="section" id="pairing">
<h3><a class="toc-backref" href="#toc-entry-26">Pairing</a></h3>
<p>As mentioned, when using Oceanic as an emitter, it <em>must</em> have been paired to the target actuator.</p>
<p>Pairing can be done through teach-in (through an exchange of specific telegrams) or through learning (putting the actuator in a specific mode, and forcing the emitter to send a telegram). Some actuators support both procedures.</p>
<p>As detailed in the next section, some actuators are able to learn a device according to various device types/EEPs (e.g. a rocker as a rocker, or as two push-buttons).</p>
<p>This choice matters: although this may not impact the telegrams to be sent by the device, it is bound to impact the behaviour of the actuator when receiving these telegrams.</p>
</div>
<div class="section" id="buttons-vs-rocker-transition-vs-state">
<h3><a class="toc-backref" href="#toc-entry-27">Buttons vs Rocker: Transition vs State</a></h3>
<p>Depending on the choice made by the user (typically as selected by pressing different buttons on the actuator, to enter a given learning mode), an actuator (e.g. a smart plug controlling a basic lamp) may learn a device (e.g. a rocker) differently (according to different EEPs).</p>
<p>For example a (single) rocker may be seen:</p>
<ul class="simple">
<li>case A: either as two independent push-buttons (a top button and an unrelated bottom one)</li>
<li>case B: or as a whole rocker (hence two associated buttons together with the memory of the current state on the actuator)</li>
</ul>
<p>A key difference is that, in case A (two push-buttons), each button taken individually may toggle the smart plug, while, in case B (rocker), pressing the top button whereas the smart plug is already passing (i.e. in the &quot;triggered&quot; state) will have no effect (e.g. the lamp remains on).</p>
<p>Said differently, case A is about toggling (forcing state transitions) while case B is about setting (forcing state values).</p>
<p>In the general case, setting (hence the rocker behaviour) may be seen as more reliable than toggling (the push-button behaviour): a given setting order may be sent multiple times to a rocker to ensure a given state is reached despite a possible message loss, whereas a single loss of a toggling message will result in being consistently from then on in the opposite state of the intended one.</p>
<p>Another approach is to enable and manage state feedback / status return through confirmation telegrams about the current state of the actuator.</p>
</div>
<div class="section" id="eltako-socket-switching-actuator-fssa">
<span id="main-test-actuator"></span><h3><a class="toc-backref" href="#toc-entry-28">Eltako Socket switching actuator FSSA</a></h3>
<p>In practice, in addition to the documentation, we found clearer to respect the following procedures:</p>
<ul class="simple">
<li>to reset: press left-button for about 3 &quot;large&quot; seconds, then the LED blinks continuously, then press the right-button for about 5 seconds, until the LED turns off</li>
<li>to learn a device as:<ul>
<li>a push-button : press left-button for about 1 &quot;large&quot; second, then the LED is on continuously, then press the right-button shortly <em>once</em>; the LED will blink once and stay fixed until a telegram is received and learnt: if for example we pressed the top bottom to generate such telegram, this button will act as a on/off toggle, whereas its associated bottom button will have no effect</li>
<li>a &quot;direction push-button&quot; (maybe a synonymous of rocker): press left-button for about 1 &quot;large&quot; second, then the LED is on continuously, then press the right-button shortly <em>twice</em>; the LED will blink twice and stay fixed until a telegram is received and learnt; in that case, even if we pressed only for example the top button (which from now on corresponds to &quot;set on&quot;), the bottom one will also be taken into account (even if it was involved in the learning stage) and will correspond to &quot;set off&quot;</li>
</ul>
</li>
</ul>
<p>Afterwards, the LED will blink once a telegram of a learnt device is received (whether or not this specified action has been learnt).</p>
<p>As mentioned in the previous section, we prefer the &quot;direction push-button&quot; mode, i.e. the rocker-based, &quot;state setting&quot; mode.</p>
</div>
</div>
</div>
<div class="section" id="support">
<h1><a class="toc-backref" href="#toc-entry-29">Support</a></h1>
<p>Bugs, questions, remarks, patches, requests for enhancements, etc. are to be reported to the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Oceanic">project interface</a> (typically <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Oceanic/issues">issues</a>) or directly at the email address mentioned at the beginning of this document.</p>
</div>
<div class="section" id="additional-information">
<h1><a class="toc-backref" href="#toc-entry-30">Additional Information</a></h1>
<ul class="simple">
<li>use <tt class="docutils literal">make <span class="pre">sync-sources-to-server</span></tt> if needing to update directly Oceanic' sources on a remote server that hosts an appropriate USB dongle</li>
<li>refer to <a class="reference external" href="http://tvaira.free.fr/projets/activites/enocean.html">EnOcean in Practice</a> (very clear information, in French)</li>
</ul>
</div>
<div class="section" id="similar-projects">
<h1><a class="toc-backref" href="#toc-entry-31">Similar Projects</a></h1>
<p>They may be used as sources of inspiration:</p>
<ul class="simple">
<li>[PY-EN] the rather complete <a class="reference external" href="https://github.com/kipe/enocean">Python EnOcean</a> library, including for its <a class="reference external" href="https://github.com/kipe/enocean/blob/master/enocean/protocol/EEP.xml">EEP (XML) information</a></li>
</ul>
<ul class="simple">
<li>a Java implementation: <a class="reference external" href="https://github.com/steveohara/enocean4j/tree/master/src/main/java/uk/co/_4ng/enocean/protocol/serial/v3/network/packet">enocean4j</a></li>
<li>the (Java) <a class="reference external" href="https://github.com/fruggy83/openocean">OpenEnocean openHAB binding</a></li>
<li>a first <a class="reference external" href="https://github.com/Cutii/enocean">Rust implementation</a></li>
</ul>
<p>Finally, there are nice, interesting integrated solutions like <a class="reference external" href="https://www.jeedom.com">Jeedom</a> that are mostly open-source (yet the <a class="reference external" href="https://market.jeedom.com/index.php?v=d&amp;p=market_display&amp;id=2622">support for Enocean</a> may require closed-source plugins to be bought).</p>
</div>
<div class="section" id="please-react">
<h1><a class="toc-backref" href="#toc-entry-32">Please React!</a></h1>
<p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, drop us a line! (for that, follow the <a class="reference internal" href="#support">Support</a> guidelines).</p>
</div>
<div class="section" id="ending-word">
<h1><a class="toc-backref" href="#toc-entry-33">Ending Word</a></h1>
<p>Have fun with Ceylan-Oceanic!</p>
<p><span class="raw-html"><center><img src="oceanic-title.png" id="responsive-image-small"></img></center></span>
</p>
<p><span class="raw-html"><a name="oceanic_bottom"></a></span></p>
</div>
</div>
</body>
</html>
